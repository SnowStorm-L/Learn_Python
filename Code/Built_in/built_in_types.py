#!/usr/local/bin/python3.7
# -*- coding: utf-8 -*-
# @Time    : 2019/4/2 3:03 PM
# @Author  : L
# @Email   : L862608263@163.com
# @File    : built_in_types.py
# @Software: PyCharm

# 内置类型

# 以下部分描述了解释器中内置的标准类型。

# 主要内置类型有数字、序列、映射、类、实例和异常。

# 有些多项集类是可变的。
# 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 None。

# 有些操作受多种对象类型的支持;特别地,实际上所有对象都可以被比较、检测逻辑值,以及转换为字符串（使用 repr() 函数或略有差异的 str() 函数).
# 后一个函数是在对象由 print() 函数输出时被隐式地调用的。

# NOTE 逻辑值检测

# 任何对象都可以进行逻辑值的检测，以便在 if 或 while 作为条件或是作为下文所述布尔运算的操作数来使用。

# 一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 __bool__() 方法且返回 False 或是定义了 __len__() 方法且返回零。

# 下面基本完整地列出了会被视为假值的内置对象:
# 1, 被定义为假值的常量: None 和 False。
# 2, 任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
# 3, 空的序列和多项集: '', (), [], {}, set(), range(0)

# 产生布尔值结果的运算和内置函数总是返回 0 或 False 作为假值，1 或 True 作为真值，除非另行说明。
# （重要例外：布尔运算 or 和 and 总是返回其中一个操作数。）

# NOTE 布尔运算 --- and, or, not

# 这些属于布尔运算，按优先级升序排列:

# x or y
# if x is false, then y, else x
# 这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。

# x and y
# if x is false, then x, else y
# 这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。

# not x
# if x is false, then True, else False
# not 的优先级比非布尔运算符低，因此 not a == b 会被解读为 not (a == b) 而 a == not b 会引发语法错误。

# NOTE 比较

# 在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。
# 比较运算可以任意串连；例如，x < y <= z 等价于 x < y and y <= z，前者的不同之处在于 y 只被求值一次
# （但在两种情况下当 x < y 结果为假值时 z 都不会被求值).

# 为什么会有严格两个字呢? (个人理解)
# 严格可能会检查类型匹配  例如 3 == '3', 3 < '5'
# (在js里面有 == 和 ===, js里面写 3 == '3'是符合的, 因为js这个==不检查类型, ===才检查类型
# <,>符号也是一样道理, 严格二字同样的道理

# 或者说  < 就是严格小于, <= 就是非严格小于 ?

# <           严格小于
# <=          小于或等于
# >           严格大于
# >=          大于或等于
# ==          等于
# !=          不等于
# is          对象标识
# is not      否定的对象标识

# 除了不同数字类型以外，不同类型的对象比较时绝对不会相等。
# 而且，某些类型（例如函数对象）仅支持简化比较形式，即任何两个该种类型的对象必定不相等。

# <, <=, > 和 >= 运算符在以下情况中将引发 TypeError 异常：

# 当比较复数与另一个内置数字类型时，当两个对象具有无法被比较的不同类型时，或在未定义次序的其他情况时。

# 具有不同标识的类的实例比较结果通常为不相等，除非类定义了 __eq__() 方法。

# 一个类实例不能与相同类或的其他实例或其他类型的对象进行排序，除非该类定义了足够多的方法，
# 包括 __lt__(), __le__(), __gt__() 以及 __ge__() (而如果你想实现常规意义上的比较操作，通常只要有 __lt__() 和 __eq__() 就可以了)。

# is 和 is not 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。

# 还有两种具有相同语法优先级的运算 in 和 not in，它们被 iterable 或实现了 __contains__() 方法的类型所支持。

