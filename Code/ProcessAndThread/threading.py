#!/usr/local/bin/python3.6.5
# -*- coding: utf-8 -*-
# @Time    : 2018/9/6 PM3:23
# @Author  : L
# @Email   : L862608263@163.com
# @File    : threading.py
# @Software: PyCharm

import threading

# NOTE 线程对象

# Thread 类表示在单独的控制线程中运行的活动。指定活动的方法有两种: 通过将可调用对象传递给构造函数, 或者重写子类中的 run() 方法。
# 在子类中不应重写其他方法 (构造函数除外)。
# 换言之,只重写此类的__init__()和 run() 方法。

# 创建线程对象后, 必须通过调用线程的 start() 方法来启动它的活动。
# 这将在单独的控制线程中调用 run() 方法。

# 线程的活动启动后, 线程将被视为 "活的"。
# 当它的 run() 方法终止时,
# 它将停止生存-通常是, 或者通过引发未处理的异常。
# is_alive() 方法测试线程是否存在。

# 其他线程可以调用线程的 join() 方法。这将阻止调用线程, 直到调用其 join() 方法的线程终止为止。

# 线程具有名称。该名称可以传递给构造函数, 并通过 name 属性读取或更改。

# 可以将线程标记为 "守护进程线程(daemon thread)"。
# 此标志的意义在于, 当只剩下守护进程线程时, 整个 Python 程序退出。
# 初始值从创建线程继承。
# 可以通过 daemon 属性或守护程序构造函数参数设置标志。

# WARNING

# 关闭时, 守护进程线程突然停止。
# 它们的资源 (如打开的文件、数据库事务等) 可能无法正确释放。
# 如果希望线程正常停止, 请使它们不后台, 并使用适当的信号机制 (如 Event).

# 有一个 "主线程(main thread)" 对象; 这对应于 Python 程序中的初始控制线程。它不是守护进程线程。

# 有可能创建 "虚拟线程(dummy thread)对象"。
# 这些线程对象对应于 "外部线程(alien threads)", 它们是从线程模块外部启动的控制线程, 例如直接从 C 代码。
# 虚拟线程对象具有有限的功能;他们总是被认为是活的和后台的, 不能 join()。由于无法检测到外部线程的终止, 因此它们永远不会被删除。

# NOTE threading.Thread

# threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
# 应始终使用关键字参数调用此构造函数。
# 参数是:
"""
    * group *应为None; 在实现ThreadGroup类时保留用于将来的扩展。
    * target *是run（）调用的可调用对象方法。 默认为None，表示不调用任何内容。
    * name *是线程名称。 默认情况下，构造唯一名称形式为“Thread-N”，其中N是小十进制数。
    * args *是目标调用的参数元组。 默认为（）。
    * kwargs *是目标关键字参数的字典调用。 默认为{}。
    如果子类重写构造函数，则必须确保调用基类构造函数（Thread .__ init __（））, 在对线程做任何其他事情之前。
"""

# 在3.3 版中更改, 添加了守护进程参数

# NOTE 方法

# 1, start()

# 启动线程的活动。
# 每个线程对象最多只能调用一次。它为对象的 run() 方法安排在单独的控制线程中调用。
# 此方法在同一线程对象上多次调用时将引发 RuntimeError 。

# 2, run()

# 表示线程活动的方法。可以在子类中重写此方法.
# 标准run()方法调用传递给对象的构造函数的可调用对象作为目标参数(如果有),分别使用args和kwargs参数中的顺序和关键字参数.

# 3, join(timeout=None)

# 等待线程终止。这将阻止调用线程, 直到调用的 join() 方法的线程终止 (通常是或通过未处理的异常), 或者在可选超时发生之前。
# 当超时参数存在而不是None时, 它应该是一个浮点数字, 指定操作的超时 (以秒为单位) (或其分数)。
# 由于 join() 总是返回None, 因此在 join() 后必须调用 is_alive() 来决定是否发生超时-如果线程是仍然存在, join() 调用超时。

# 当超时参数不存在或None时, 操作将阻塞, 直到线程终止。

# 线程可以多次 join()。

# 如果尝试加入当前线程, 将导致死锁, 则 join() 将引发 RuntimeError 。在启动线程之前 join() 它也是一个错误, 尝试这样做会引发相同的异常。

# 4, name

# 仅用于标识目的的字符串。它没有语义。可以给多个线程相同的名称。初始名称由构造函数设置。

# getName()
# setName()
#      用于名称的旧getter / setter API; 直接在属性上更改就好。

# 5, ident

# 此线程的 "线程标识符", 或者如果线程尚未启动, 则为None 。这是一个非零整数。请参见 get_ident() 函数。
# 线程标识符可以在线程退出并创建另一个线程时回收。即使线程已退出, 该标识符也可用。

# 6, is_alive()

# 返回线程是否存在。
#
# 此方法仅在运行 run() 方法开始之前返回True , 直到 run() 方法终止。模块函数 enumerate() 返回所有活线程的列表

# 7, daemon

# 一个布尔值, 指示此线程是否为守护进程线程 (True) 或否 (False)。这必须在调用 start() 之前设置, 否则将引发 RuntimeError 。
# 它的初始值从创建线程继承;主线程不是守护进程线程, 因此在主线程中创建的所有线程都默认为 daemon = False.
# 当没有活着的非守护进程线程离开时, 整个 Python 程序退出。

# isDaemon()
# setDaemon()
#   用于daemon的旧getter / setter API; 直接在属性上更改就好。
